/**
 * Kaldi speech recognition REST API
 * Simple REST interface for posting tasks for non realtime speech recognition
 *
 * The version of the OpenAPI document: 0.9.0
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.0.0-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include "TaskApi.h"
#include "apiClient/IHttpBody.h"
#include "apiClient/JsonBody.h"
#include "apiClient/MultipartFormData.h"
#include "apiClient/OctetStreamData.h"

#include <unordered_set>
#include <boost/algorithm/string/replace.hpp>


namespace mvshyvk {
namespace kaldi {
namespace client {
namespace api {

using namespace mvshyvk::kaldi::client::model;

TaskApi::TaskApi(std::shared_ptr<const ApiClient> apiClient)
	: m_ApiClient(apiClient)
{
}

TaskApi::~TaskApi()
{
}

pplx::task<std::shared_ptr<TaskId>> TaskApi::taskPost(boost::optional<std::shared_ptr<HttpContent>> body) const
{
	std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(m_ApiClient->getConfiguration());
	utility::string_t localVarPath = utility::conversions::to_string_t("/task");

	std::map<utility::string_t, utility::string_t> localVarQueryParams;
	std::map<utility::string_t, utility::string_t> localVarHeaderParams(localVarApiConfiguration->getDefaultHeaders());
	std::map<utility::string_t, utility::string_t> localVarFormParams;
	std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

	std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
	localVarResponseHttpContentTypes.insert(utility::conversions::to_string_t("application/json"));

	utility::string_t localVarResponseHttpContentType;

	// use JSON if possible
	if (localVarResponseHttpContentTypes.size() == 0)
	{
		localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
	}
	// JSON
	else if (localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end())
	{
		localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
	}
	// multipart formdata
	else if (localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end())
	{
		localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
	}
	else
	{
		throw ApiException(400, utility::conversions::to_string_t("TaskApi->taskPost does not produce any supported media type"));
	}

	localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

	std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;
	localVarConsumeHttpContentTypes.insert(utility::conversions::to_string_t("application/octet-stream"));


	std::shared_ptr<IHttpBody> localVarHttpBody;
	utility::string_t localVarRequestHttpContentType;

	// use JSON if possible
	if (localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end())
	{
		localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
		web::json::value localVarJson;

		localVarJson = ModelBase::toJson(body.get());

		localVarHttpBody = std::shared_ptr<IHttpBody>(new JsonBody(localVarJson));
	}
	// multipart formdata
	else if (localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end())
	{
		localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
		std::shared_ptr<MultipartFormData> localVarMultipart(new MultipartFormData);
		localVarMultipart->add(ModelBase::toHttpContent(utility::conversions::to_string_t("body"), body.get()));


		localVarHttpBody = localVarMultipart;
		localVarRequestHttpContentType += utility::conversions::to_string_t("; boundary=") + localVarMultipart->getBoundary();
	}
	// application/octet-stream
	else if (localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/octet-stream")) != localVarConsumeHttpContentTypes.end())
	{
		localVarRequestHttpContentType = utility::conversions::to_string_t("application/octet-stream");
		localVarHttpBody = std::make_shared<OctetStreamData>(body.get());
	}
	else
	{
		throw ApiException(415, utility::conversions::to_string_t("TaskApi->taskPost does not consume any supported media type"));
	}

	// authentication (password) required
	// oauth2 authentication is added automatically as part of the http_client_config

	return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("POST"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
		.then([=](web::http::http_response localVarResponse)
		{
			if (m_ApiClient->getResponseHandler())
			{
				m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
			}

			// 1xx - informational : OK
			// 2xx - successful       : OK
			// 3xx - redirection   : OK
			// 4xx - client error  : not OK
			// 5xx - client error  : not OK
			if (localVarResponse.status_code() >= 400)
			{
				throw ApiException(localVarResponse.status_code()
					, utility::conversions::to_string_t("error calling taskPost: ") + localVarResponse.reason_phrase()
					, std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
			}

			// check response content type
			if (localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
			{
				utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
				if (localVarContentType.find(localVarResponseHttpContentType) == std::string::npos)
				{
					throw ApiException(500
						, utility::conversions::to_string_t("error calling taskPost: unexpected response type: ") + localVarContentType
						, std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
				}
			}

			return localVarResponse.extract_string();
		})
		.then([=](utility::string_t localVarResponse)
			{
				std::shared_ptr<TaskId> localVarResult(new TaskId());

				if (localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
				{
					web::json::value localVarJson = web::json::value::parse(localVarResponse);

					ModelBase::fromJson(localVarJson, localVarResult);
				}
				// else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
				// {
				// TODO multipart response parsing
				// }
				else
				{
					throw ApiException(500
						, utility::conversions::to_string_t("error calling taskPost: unsupported response type"));
				}

				return localVarResult;
			});
}

auto TaskApi::taskTaskIdStatusGet(utility::string_t taskId) const ->
pplx::task<std::pair<std::shared_ptr<Result>, web::http::status_code>>
{
	std::shared_ptr<const ApiConfiguration> localVarApiConfiguration(m_ApiClient->getConfiguration());
	utility::string_t localVarPath = utility::conversions::to_string_t("/task/{taskId}/status");
	boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("taskId") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(taskId));

	std::map<utility::string_t, utility::string_t> localVarQueryParams;
	std::map<utility::string_t, utility::string_t> localVarHeaderParams(localVarApiConfiguration->getDefaultHeaders());
	std::map<utility::string_t, utility::string_t> localVarFormParams;
	std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

	std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
	localVarResponseHttpContentTypes.insert(utility::conversions::to_string_t("application/json"));

	utility::string_t localVarResponseHttpContentType;

	// use JSON if possible
	if (localVarResponseHttpContentTypes.size() == 0)
	{
		localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
	}
	// JSON
	else if (localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end())
	{
		localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
	}
	// multipart formdata
	else if (localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end())
	{
		localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
	}
	else
	{
		throw ApiException(400, utility::conversions::to_string_t("TaskApi->taskTaskIdStatusGet does not produce any supported media type"));
	}

	localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

	std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;


	std::shared_ptr<IHttpBody> localVarHttpBody;
	utility::string_t localVarRequestHttpContentType;

	// use JSON if possible
	if (localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end())
	{
		localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
	}
	// multipart formdata
	else if (localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end())
	{
		localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
	}
	else
	{
		throw ApiException(415, utility::conversions::to_string_t("TaskApi->taskTaskIdStatusGet does not consume any supported media type"));
	}

	// authentication (password) required
	// oauth2 authentication is added automatically as part of the http_client_config

	return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("GET"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
		.then([=](web::http::http_response localVarResponse)
		{
			if (m_ApiClient->getResponseHandler())
			{
				m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
			}

			// 1xx - informational : OK
			// 2xx - successful       : OK
			// 3xx - redirection   : OK
			// 4xx - client error  : not OK
			// 5xx - client error  : not OK
			if (localVarResponse.status_code() >= 400)
			{
				throw ApiException(localVarResponse.status_code()
					, utility::conversions::to_string_t("error calling taskTaskIdStatusGet: ") + localVarResponse.reason_phrase()
					, std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
			}

			// check response content type
			if (localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
			{
				utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
				if (localVarContentType.find(localVarResponseHttpContentType) == std::string::npos)
				{
					throw ApiException(500
						, utility::conversions::to_string_t("error calling taskTaskIdStatusGet: unexpected response type: ") + localVarContentType
						, std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
				}
			}

			auto responseBody = localVarResponse.extract_string().get();
			std::shared_ptr<Result> localVarResult(new Result());

			if (localVarResponse.status_code() == web::http::status_code(204))
			{
				return std::make_pair(localVarResult, localVarResponse.status_code());
			}

			if (localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
			{
				web::json::value localVarJson = web::json::value::parse(responseBody);

				ModelBase::fromJson(localVarJson, localVarResult);
			}
			// else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
			// {
			// TODO multipart response parsing
			// }
			else
			{
				throw ApiException(500
					, utility::conversions::to_string_t("error calling taskTaskIdStatusGet: unsupported response type"));
			}

			return std::make_pair(localVarResult, localVarResponse.status_code());
		});
}

}
}
}
}

